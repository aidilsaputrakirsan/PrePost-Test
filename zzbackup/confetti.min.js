/**
 * Simplified version of canvas-confetti for local hosting
 * Based on canvas-confetti by Kiril Vatev
 * https://github.com/catdad/canvas-confetti
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.confetti = factory());
  }(this, function () {
    'use strict';
  
    function randomFromTo(from, to) {
      return Math.floor(Math.random() * (to - from) + from);
    }
  
    function createCanvas(zIndex) {
      const canvas = document.createElement('canvas');
      canvas.style.position = 'fixed';
      canvas.style.top = '0px';
      canvas.style.left = '0px';
      canvas.style.pointerEvents = 'none';
      canvas.style.zIndex = zIndex.toString();
      return canvas;
    }
  
    function randomColor() {
      return '#' + Math.floor(Math.random() * 16777215).toString(16);
    }
  
    // Simplified confetti function
    return function confetti(options) {
      options = options || {};
      
      const particleCount = options.particleCount || 100;
      const angle = options.angle || 90;
      const spread = options.spread || 70;
      const startVelocity = options.startVelocity || 45;
      const decay = options.decay || 0.9;
      const gravity = options.gravity || 1;
      const colors = options.colors || ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff'];
      const ticks = options.ticks || 200;
      const zIndex = options.zIndex || 100;
      const origin = options.origin || { x: 0.5, y: 0.5 };
      
      const canvas = createCanvas(zIndex);
      document.body.appendChild(canvas);
      
      const context = canvas.getContext('2d');
      let animationFrame;
      let particles = [];
      let tick = 0;
      
      // Resize canvas to match window dimensions
      const resizeCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      };
      
      window.addEventListener('resize', resizeCanvas, false);
      resizeCanvas();
      
      // Create particles
      for (let i = 0; i < particleCount; i++) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        particles.push({
          x: origin.x * canvas.width,
          y: origin.y * canvas.height,
          angle: randomFromTo(angle - spread / 2, angle + spread / 2),
          speed: randomFromTo(startVelocity / 2, startVelocity),
          velocity: (Math.random() - 0.5) * startVelocity,
          size: Math.random() * 10 + 5,
          color: color,
          opacity: 1
        });
      }
      
      // Render animation
      const render = () => {
        tick++;
        
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        particles.forEach((particle, i) => {
          particle.velocity *= decay;
          particle.x += Math.cos(particle.angle * Math.PI / 180) * particle.velocity;
          particle.y += Math.sin(particle.angle * Math.PI / 180) * particle.velocity + gravity;
          particle.opacity -= 0.01;
          
          const highlight = Math.floor(particle.size / 2);
          
          context.beginPath();
          context.fillStyle = particle.color;
          context.globalAlpha = particle.opacity > 0 ? particle.opacity : 0;
          context.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2, false);
          context.fill();
        });
        
        // Remove expired particles
        particles = particles.filter(particle => particle.opacity > 0);
        
        if (tick < ticks && particles.length > 0) {
          animationFrame = requestAnimationFrame(render);
        } else {
          // Clean up
          cancelAnimationFrame(animationFrame);
          canvas.remove();
        }
      };
      
      // Start animation
      render();
      
      return {
        clear: function() {
          cancelAnimationFrame(animationFrame);
          canvas.remove();
        }
      };
    };
  }));